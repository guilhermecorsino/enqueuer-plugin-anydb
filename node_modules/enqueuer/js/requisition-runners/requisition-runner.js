"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../loggers/logger");
const requisition_reporter_1 = require("../reporters/requisition-reporter");
const json_placeholder_replacer_1 = require("json-placeholder-replacer");
const store_1 = require("../configurations/store");
const requisition_default_reports_1 = require("../models-defaults/outputs/requisition-default-reports");
const file_content_map_creator_1 = require("../configurations/file-content-map-creator");
const iterations_evaluator_1 = require("./iterations-evaluator");
const component_parent_backupper_1 = require("../components/component-parent-backupper");
const component_importer_1 = require("./component-importer");
const requisition_adopter_1 = require("../components/requisition-adopter");
const notification_emitter_1 = require("../notifications/notification-emitter");
const test_model_1 = require("../models/outputs/test-model");
class RequisitionRunner {
    constructor(requisition) {
        this.childrenRequisitionRunner = [];
        this.requisition = new requisition_adopter_1.RequisitionAdopter(requisition).getRequisition();
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.Logger.info(`Running requisition '${this.requisition.name}'`);
            try {
                this.importRequisition();
            }
            catch (err) {
                logger_1.Logger.error(`Error importing requisition`);
                const report = requisition_default_reports_1.RequisitionDefaultReports.createRunningError(this.requisition, err);
                this.emitNotification(report);
                return [report];
            }
            this.replaceVariables();
            const evaluatedIterations = new iterations_evaluator_1.IterationsEvaluator().iterations(this.requisition.iterations);
            if (evaluatedIterations <= 0) {
                logger_1.Logger.info(`Requisition will be skipped duo no iterations`);
                const report = requisition_default_reports_1.RequisitionDefaultReports.createSkippedReport(this.requisition);
                this.emitNotification(report);
                return [report];
            }
            else if (this.requisition.ignore) {
                logger_1.Logger.info(`Requisition will be ignored`);
                const report = requisition_default_reports_1.RequisitionDefaultReports.createIgnoredReport(this.requisition);
                this.emitNotification(report);
                return [report];
            }
            return yield this.iterateRequisition(evaluatedIterations);
        });
    }
    iterateRequisition(iterations) {
        return __awaiter(this, void 0, void 0, function* () {
            const reports = [];
            for (let iterationCounter = 0; iterationCounter < iterations; ++iterationCounter) {
                try {
                    this.replaceVariables();
                    this.requisition.iteration = iterationCounter;
                    this.requisition.totalIterations = iterations;
                    logger_1.Logger.trace(`Requisition runner starting requisition reporter for '${this.requisition.name}'`);
                    const report = yield this.startRequisitionReporter();
                    reports.push(report);
                    this.emitNotification(report);
                }
                catch (err) {
                    reports.push(requisition_default_reports_1.RequisitionDefaultReports.createRunningError(this.requisition, err.toString()));
                    logger_1.Logger.error(err);
                }
            }
            return reports;
        });
    }
    importRequisition() {
        if (this.requisition.import) {
            this.requisition = new component_importer_1.ComponentImporter().importRequisition(this.requisition);
        }
    }
    interrupt() {
        return __awaiter(this, void 0, void 0, function* () {
            const report = yield this.requisitionReporter.interrupt();
            this.emitNotification(report);
            return report;
        });
    }
    emitNotification(report) {
        notification_emitter_1.NotificationEmitter.emit(notification_emitter_1.Notifications.REQUISITION_RAN, report);
    }
    replaceVariables() {
        logger_1.Logger.debug(`Evaluating variables of requisition '${this.requisition.name}'`);
        const componentParentBackupper = new component_parent_backupper_1.ComponentParentBackupper();
        componentParentBackupper.removeParents(this.requisition);
        const fileMapCreator = new file_content_map_creator_1.FileContentMapCreator(this.requisition);
        const fileReplaced = new json_placeholder_replacer_1.JsonPlaceholderReplacer()
            .addVariableMap(fileMapCreator.getMap())
            .replace(this.requisition);
        this.requisition = new json_placeholder_replacer_1.JsonPlaceholderReplacer()
            .addVariableMap(store_1.Store.getData())
            .replace(fileReplaced);
        componentParentBackupper.putParentsBack(this.requisition);
    }
    startRequisitionReporter() {
        return __awaiter(this, void 0, void 0, function* () {
            this.requisitionReporter = new requisition_reporter_1.RequisitionReporter(this.requisition);
            const report = yield Promise.race([
                this.timeoutPath(),
                this.happyPath()
            ]);
            logger_1.Logger.info(`Requisition '${report.name}' is over (${report.valid}) - ${report.time ? report.time.totalTime : 0}ms`);
            logger_1.Logger.trace(`Store keys: ${Object.keys(store_1.Store.getData()).join('; ')}`);
            return report;
        });
    }
    timeoutPath() {
        return __awaiter(this, void 0, void 0, function* () {
            const report = yield this.requisitionReporter.startTimeout();
            report.requisitions = yield Promise.all(this.childrenRequisitionRunner.map(childRunner => childRunner.interrupt()));
            logger_1.Logger.debug(`Requisition '${this.requisition.name}' timed out`);
            return report;
        });
    }
    happyPath() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requisitionReporter.delay();
            logger_1.Logger.debug(`Handling requisitions children of '${this.requisition.name}'`);
            let childrenReport = yield this.executeChildren();
            const report = yield this.requisitionReporter.execute();
            report.requisitions = childrenReport;
            report.valid = report.valid &&
                report.requisitions.every((requisition) => test_model_1.testModelIsPassing(requisition)) &&
                Object.keys(report.hooks || {}).every((key) => report.hooks ? report.hooks[key].valid : true);
            logger_1.Logger.debug(`Requisition ${this.requisition.name} went through the happy path`);
            return report;
        });
    }
    executeChildren() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.requisition.parallel) {
                const models = yield Promise.all(this.requisition.requisitions
                    .map((child, index) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.executeChild(child, index);
                })));
                return models.reduce((acc, child) => acc.concat(child), []);
            }
            else {
                let childrenReport = [];
                let index = 0;
                for (const child of this.requisition.requisitions) {
                    childrenReport = childrenReport.concat(yield this.executeChild(child, index));
                    ++index;
                }
                return childrenReport;
            }
        });
    }
    executeChild(child, index) {
        return __awaiter(this, void 0, void 0, function* () {
            child.parent = this.requisition;
            const childRunner = new RequisitionRunner(child);
            this.childrenRequisitionRunner.push(childRunner);
            const requisitionModels = yield childRunner.run();
            this.requisition.requisitions[index] = childRunner.requisition;
            return requisitionModels;
        });
    }
}
exports.RequisitionRunner = RequisitionRunner;
