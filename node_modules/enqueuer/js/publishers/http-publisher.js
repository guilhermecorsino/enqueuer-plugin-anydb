"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const publisher_1 = require("./publisher");
const logger_1 = require("../loggers/logger");
const http_requester_1 = require("../pools/http-requester");
const publisher_protocol_1 = require("../protocols/publisher-protocol");
const http_authentication_factory_1 = require("../http-authentications/http-authentication-factory");
class HttpPublisher extends publisher_1.Publisher {
    constructor(publish) {
        super(publish);
        this['method'] = publish.method || 'get';
        this.payload = this.payload || '';
        this['headers'] = this.headers || {};
        this['timeout'] = this.timeout || 3000;
    }
    publish() {
        return __awaiter(this, void 0, void 0, function* () {
            this.insertAuthentication();
            const response = yield new http_requester_1.HttpRequester(this.url, this.method.toLowerCase(), this.headers, this.payload, this.timeout)
                .request();
            this.executeHookEvent('onResponseReceived', response);
            //NOTE: Deprecation proposes
            this.executeHookEvent('onMessageReceived', response);
        });
    }
    insertAuthentication() {
        if (this.authentication) {
            const authenticator = new http_authentication_factory_1.HttpAuthenticationFactory().create(this.authentication);
            const authentication = authenticator.generate();
            if (authentication) {
                this['headers'] = Object.assign(this.headers, authentication);
            }
            else {
                logger_1.Logger.warning(`No http authentication method was generated from: ${this.authentication}`);
            }
        }
    }
}
function entryPoint(mainInstance) {
    const protocol = new publisher_protocol_1.PublisherProtocol('http', (publisherModel) => new HttpPublisher(publisherModel), {
        description: 'The HTTP publisher provides an implementation of http requisitions',
        libraryHomepage: 'https://github.com/request/request',
        schema: {
            attributes: {
                url: {
                    required: true,
                    type: 'string',
                    example: 'https://github.com/enqueuer-land/enqueuer'
                },
                method: {
                    required: false,
                    type: 'string',
                    defaultValue: 'GET',
                    listValues: ['GET', 'POST', 'PATCH', 'PUT', 'OPTIONS', 'HEAD', 'DELETE']
                },
                payload: {
                    required: true,
                    type: 'text'
                },
                timeout: {
                    required: false,
                    type: 'int',
                    defaultValue: 3000,
                    suffix: 'ms'
                },
                headers: {
                    description: '',
                    type: 'object',
                    defaultValue: {}
                },
            },
            hooks: {
                onResponseReceived: {
                    description: 'Hook called when the publisher gets a response from the server',
                    arguments: {
                        statusCode: {},
                        headers: {},
                        body: {},
                    }
                }
            }
        }
    })
        .addAlternativeName('http-client', 'https', 'https-client')
        .setLibrary('request');
    mainInstance.protocolManager.addProtocol(protocol);
}
exports.entryPoint = entryPoint;
