"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prettyjson_1 = __importDefault(require("prettyjson"));
const null_subscription_1 = require("../subscriptions/null-subscription");
const null_publisher_1 = require("../publishers/null-publisher");
const prettyjson_config_1 = require("../outputs/prettyjson-config");
const logger_1 = require("../loggers/logger");
class ProtocolManager {
    constructor() {
        this.protocols = [];
    }
    createPublisher(publisherModel) {
        const matchingPublishers = this.protocols
            .filter((protocol) => protocol.isPublisher())
            .filter((protocol) => protocol.matches(publisherModel.type))
            .map((protocol) => protocol.create(publisherModel));
        if (matchingPublishers.length > 0) {
            return matchingPublishers[0];
        }
        logger_1.Logger.error(`No publisher was found with '${publisherModel.type}'`);
        return new null_publisher_1.NullPublisher(publisherModel);
    }
    createSubscription(subscriptionModel) {
        const matchingSubscriptions = this.protocols
            .filter((protocol) => protocol.isSubscription())
            .filter((protocol) => protocol.matches(subscriptionModel.type))
            .map((protocol) => protocol.create(subscriptionModel));
        if (matchingSubscriptions.length > 0) {
            return matchingSubscriptions[0];
        }
        logger_1.Logger.error(`No subscription was found with '${subscriptionModel.type}'`);
        return new null_subscription_1.NullSubscription(subscriptionModel);
    }
    addProtocol(protocol) {
        this.protocols.push(protocol);
    }
    describeMatchingProtocols(description = '') {
        const matchingProtocols = this.getProtocolsDescription(description);
        console.log(prettyjson_1.default.render(matchingProtocols, prettyjson_config_1.getPrettyJsonConfig()));
        return matchingProtocols.publishers.length + matchingProtocols.subscriptions.length > 0;
    }
    getProtocolsDescription(protocol = '') {
        return {
            publishers: this.protocols
                //NOTE: function check for retro compatibilities proposes
                .filter((protocol) => protocol.isPublisher && protocol.isPublisher())
                .filter((publisher) => publisher.matches(protocol))
                .map(protocol => protocol.getDescription()),
            subscriptions: this.protocols
                //NOTE: function check for retro compatibilities proposes
                .filter((protocol) => protocol.isSubscription && protocol.isSubscription())
                .filter((subscription) => subscription.matches(protocol))
                .map(protocol => protocol.getDescription())
        };
    }
}
exports.ProtocolManager = ProtocolManager;
