"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const date_controller_1 = require("../../timers/date-controller");
const logger_1 = require("../../loggers/logger");
const dynamic_modules_manager_1 = require("../../plugins/dynamic-modules-manager");
const event_executor_1 = require("../../events/event-executor");
const event_1 = require("../../models/events/event");
const object_decycler_1 = require("../../object-parser/object-decycler");
const test_model_1 = require("../../models/outputs/test-model");
class PublisherReporter {
    constructor(publisher) {
        this.published = false;
        this.report = {
            id: publisher.id,
            name: publisher.name,
            ignored: publisher.ignore,
            valid: true,
            hooks: {
                [event_1.DefaultHookEvents.ON_INIT]: { valid: true, tests: [] },
                [event_1.DefaultHookEvents.ON_FINISH]: { valid: true, tests: [] }
            },
            type: publisher.type
        };
        this.startTime = new Date();
        this.executeOnInitFunction(publisher);
        logger_1.Logger.debug(`Trying to instantiate publisher from '${publisher.type}'`);
        this.publisher = dynamic_modules_manager_1.DynamicModulesManager.getInstance().getProtocolManager().createPublisher(publisher);
        this.publisher.registerHookEventExecutor((eventName, args) => this.executeHookEvent(eventName, args));
    }
    publish() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.publisher.ignore) {
                    logger_1.Logger.trace(`Ignoring publisher ${this.report.name}`);
                }
                else {
                    logger_1.Logger.trace(`Publishing ${this.report.name}`);
                    yield this.publisher.publish();
                    logger_1.Logger.debug(`${this.report.name} published`);
                    this.report.publishTime = new date_controller_1.DateController().toString();
                    this.published = true;
                }
            }
            catch (err) {
                logger_1.Logger.error(`'${this.report.name}' fail publishing: ${err}`);
                this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].tests.push({ name: 'Published', valid: false, description: err.toString() });
                this.report.valid = false;
                throw err;
            }
        });
    }
    getReport() {
        return this.report;
    }
    onFinish() {
        if (!this.publisher.ignore) {
            this.executeHookEvent(event_1.DefaultHookEvents.ON_FINISH);
            this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].tests.push({
                name: 'Published',
                valid: this.published,
                description: 'Published successfully'
            });
            this.report.valid = this.report.valid && this.published;
        }
    }
    executeHookEvent(eventName, args = {}, publisher = this.publisher) {
        if (!publisher.ignore) {
            args.elapsedTime = new Date().getTime() - this.startTime.getTime();
            const eventExecutor = new event_executor_1.EventExecutor(publisher, eventName, 'publisher');
            Object.keys(args).forEach((key) => {
                eventExecutor.addArgument(key, args[key]);
            });
            const tests = eventExecutor.execute();
            const valid = tests.every((test) => test_model_1.testModelIsPassing(test));
            this.report.hooks[eventName] = {
                arguments: new object_decycler_1.ObjectDecycler().decycle(args),
                tests: tests,
                valid: valid
            };
            this.report.valid = this.report.valid && valid;
        }
    }
    executeOnInitFunction(publisher) {
        if (!publisher.ignore) {
            this.executeHookEvent(event_1.DefaultHookEvents.ON_INIT, {}, publisher);
        }
    }
}
exports.PublisherReporter = PublisherReporter;
