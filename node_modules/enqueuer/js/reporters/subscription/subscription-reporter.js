"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../../loggers/logger");
const date_controller_1 = require("../../timers/date-controller");
const timeout_1 = require("../../timers/timeout");
const subscription_final_reporter_1 = require("./subscription-final-reporter");
const dynamic_modules_manager_1 = require("../../plugins/dynamic-modules-manager");
const event_executor_1 = require("../../events/event-executor");
const event_1 = require("../../models/events/event");
const object_decycler_1 = require("../../object-parser/object-decycler");
const test_model_1 = require("../../models/outputs/test-model");
const hook_reporter_1 = require("../hook-reporter");
class SubscriptionReporter {
    constructor(subscriptionAttributes) {
        this.hasTimedOut = false;
        this.subscribed = false;
        this.startTime = new date_controller_1.DateController();
        this.report = {
            id: subscriptionAttributes.id,
            name: subscriptionAttributes.name,
            ignored: subscriptionAttributes.ignore,
            type: subscriptionAttributes.type,
            hooks: {
                [event_1.DefaultHookEvents.ON_INIT]: { valid: true, tests: [] },
                [event_1.DefaultHookEvents.ON_FINISH]: { valid: true, tests: [] }
            },
            valid: true
        };
        this.executeOnInitFunction(subscriptionAttributes);
        logger_1.Logger.debug(`Instantiating subscription ${subscriptionAttributes.type}`);
        this.subscription = dynamic_modules_manager_1.DynamicModulesManager.getInstance().getProtocolManager().createSubscription(subscriptionAttributes);
        this.subscription.registerHookEventExecutor((eventName, args) => this.executeHookEvent(eventName, args));
        if (subscriptionAttributes.timeout === undefined) {
            this.subscription.timeout = SubscriptionReporter.DEFAULT_TIMEOUT;
        }
        else if (subscriptionAttributes.timeout <= 0) {
            delete this.subscription.timeout;
        }
        this.killListener = (signal) => this.handleKillSignal(signal, this.subscription.type || 'undefined');
    }
    hasFinished() {
        return this.subscription.ignore ||
            this.subscription.messageReceived ||
            this.hasTimedOut;
    }
    startTimeout(onTimeOutCallback) {
        if (this.subscription.timeout) {
            logger_1.Logger.debug(`Starting subscription '${this.subscription.name}' timeout`);
            new timeout_1.Timeout(() => {
                if (!this.subscription.messageReceived) {
                    this.totalTime = new date_controller_1.DateController();
                    const message = `Subscription '${this.subscription.name}' stopped waiting because it has timed out`;
                    logger_1.Logger.info(message);
                    this.hasTimedOut = true;
                    onTimeOutCallback();
                }
            }).start(this.subscription.timeout);
        }
    }
    subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.subscription.ignore) {
                logger_1.Logger.trace(`Subscription '${this.subscription.name}' is ignored`);
            }
            else {
                try {
                    logger_1.Logger.trace(`Starting '${this.subscription.name}' time out`);
                    logger_1.Logger.trace(`Subscription '${this.subscription.name}' is subscribing`);
                    yield this.subscription.subscribe();
                    yield this.handleSubscription();
                }
                catch (err) {
                    const message = `Subscription '${this.subscription.name}' is unable to subscribe: ${err}`;
                    logger_1.Logger.error(message);
                    this.subscribeError = `${err}`;
                    throw err;
                }
            }
        });
    }
    receiveMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.subscription.ignore) {
                try {
                    yield this.subscription.receiveMessage();
                    logger_1.Logger.debug(`${this.subscription.name} received its message`);
                    this.handleMessageArrival();
                    yield this.sendSyncResponse();
                    logger_1.Logger.trace(`Subscription '${this.subscription.name}' has finished its job`);
                }
                catch (err) {
                    this.subscription.unsubscribe().catch(console.log.bind(console));
                    logger_1.Logger.error(`Subscription '${this.subscription.name}' is unable to receive message: ${err}`);
                    throw err;
                }
            }
        });
    }
    handleSubscription() {
        return __awaiter(this, void 0, void 0, function* () {
            process.once('SIGINT', this.killListener)
                .once('SIGTERM', this.killListener);
            if (this.hasTimedOut) {
                const message = `Subscription '${this.subscription.name}' subscription because it has timed out`;
                logger_1.Logger.error(message);
                return false;
            }
            else {
                this.report.subscriptionTime = new date_controller_1.DateController().toString();
                this.subscribed = true;
                return true;
            }
        });
    }
    sendSyncResponse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                logger_1.Logger.debug(`Subscription ${this.subscription.type} sending synchronous response`);
                yield this.subscription.sendResponse();
            }
            catch (err) {
                logger_1.Logger.warning(`Error ${this.subscription.type} synchronous response sending: ${err}`);
                this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].tests = this.report.hooks[event_1.DefaultHookEvents.ON_FINISH]
                    .tests.concat({ valid: false, name: 'Response sent', description: `${err}` });
            }
        });
    }
    getReport() {
        const time = {
            timeout: this.subscription.timeout
        };
        if (!this.totalTime) {
            this.totalTime = new date_controller_1.DateController();
        }
        time.totalTime = this.totalTime.getTime() - this.startTime.getTime();
        const finalReporter = new subscription_final_reporter_1.SubscriptionFinalReporter({
            subscribed: this.subscribed,
            avoidable: this.subscription.avoid,
            hasMessage: this.subscription.messageReceived,
            time: time,
            subscribeError: this.subscribeError,
            ignore: this.subscription.ignore
        });
        const finalReport = finalReporter.getReport();
        this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].tests = this.report.hooks[event_1.DefaultHookEvents.ON_FINISH]
            .tests.concat(finalReport);
        this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].valid = this.report.hooks[event_1.DefaultHookEvents.ON_FINISH].valid
            && finalReport.every(report => test_model_1.testModelIsPassing(report));
        this.report.valid = this.report.valid && Object.keys(this.report.hooks || {})
            .every((key) => this.report.hooks ? this.report.hooks[key].valid : true);
        return this.report;
    }
    unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            process.removeListener('SIGINT', this.killListener)
                .removeListener('SIGTERM', this.killListener);
            logger_1.Logger.debug(`Unsubscribing subscription ${this.subscription.type}`);
            if (this.subscribed) {
                return this.subscription.unsubscribe();
            }
        });
    }
    onFinish() {
        logger_1.Logger.trace(`Executing subscription onFinish`);
        if (!this.subscription.ignore) {
            this.executeHookEvent(event_1.DefaultHookEvents.ON_FINISH);
        }
    }
    executeHookEvent(eventName, args = {}, subscription = this.subscription) {
        if (!subscription.ignore) {
            args.elapsedTime = new Date().getTime() - this.startTime.getTime();
            const eventExecutor = new event_executor_1.EventExecutor(subscription, eventName, 'subscription');
            if (typeof args === 'object') {
                Object.keys(args).forEach((key) => {
                    eventExecutor.addArgument(key, args[key]);
                });
            }
            const tests = eventExecutor.execute();
            const valid = tests.every((test) => test_model_1.testModelIsPassing(test));
            const hookModel = {
                arguments: new object_decycler_1.ObjectDecycler().decycle(args),
                tests: tests,
                valid: valid
            };
            this.report.hooks[eventName] = new hook_reporter_1.HookReporter(this.report.hooks[eventName]).addValues(hookModel);
        }
    }
    handleMessageArrival() {
        if (!this.hasTimedOut) {
            logger_1.Logger.debug(`${this.subscription.name} stop waiting because it has received its message`);
            this.subscription.messageReceived = true;
            this.totalTime = new date_controller_1.DateController();
        }
        else {
            logger_1.Logger.info(`${this.subscription.name} has received message in a unable time`);
        }
        logger_1.Logger.debug(`${this.subscription.name} handled message arrival`);
    }
    executeOnInitFunction(subscriptionAttributes) {
        if (!subscriptionAttributes.ignore) {
            this.executeHookEvent(event_1.DefaultHookEvents.ON_INIT, {}, subscriptionAttributes);
        }
    }
    handleKillSignal(signal, type) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.Logger.fatal(`Subscription reporter '${type}' handling kill signal ${signal}`);
            yield this.unsubscribe();
            logger_1.Logger.fatal(`Subscription reporter '${type}' unsubscribed`);
        });
    }
}
SubscriptionReporter.DEFAULT_TIMEOUT = 3 * 1000;
exports.SubscriptionReporter = SubscriptionReporter;
