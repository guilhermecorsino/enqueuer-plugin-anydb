"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const requisition_report_generator_1 = require("./requisition-report-generator");
const logger_1 = require("../loggers/logger");
const multi_subscriptions_reporter_1 = require("./subscription/multi-subscriptions-reporter");
const multi_publishers_reporter_1 = require("./publishers/multi-publishers-reporter");
const event_executor_1 = require("../events/event-executor");
const event_1 = require("../models/events/event");
class RequisitionReporter {
    constructor(requisitionAttributes) {
        this.hasFinished = false;
        this.requisitionAttributes = requisitionAttributes;
        if (this.requisitionAttributes.timeout === undefined) {
            this.timeout = RequisitionReporter.DEFAULT_TIMEOUT;
        }
        else if (this.requisitionAttributes.timeout > 0) {
            this.timeout = this.requisitionAttributes.timeout;
        }
        this.reportGenerator = new requisition_report_generator_1.RequisitionReportGenerator(this.requisitionAttributes, this.timeout);
        this.startTime = new Date();
        this.executeOnInitFunction();
        this.multiSubscriptionsReporter = new multi_subscriptions_reporter_1.MultiSubscriptionsReporter(this.requisitionAttributes.subscriptions);
        this.multiPublishersReporter = new multi_publishers_reporter_1.MultiPublishersReporter(this.requisitionAttributes.publishers);
    }
    delay() {
        return __awaiter(this, void 0, void 0, function* () {
            const delay = this.requisitionAttributes.delay || 0;
            if (delay > 0) {
                logger_1.Logger.info(`Delaying requisition '${this.requisitionAttributes.name}' for ${delay}ms`);
                return yield new Promise((resolve) => setTimeout(() => resolve(), delay));
            }
        });
    }
    startTimeout() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (this.timeout) {
                    logger_1.Logger.debug('Starting requisition time out');
                    yield new Promise((resolve) => setTimeout(() => resolve(), this.timeout));
                    if (!this.hasFinished) {
                        logger_1.Logger.info(`Requisition '${this.requisitionAttributes.name}' timed out`);
                        yield this.onRequisitionFinish();
                        resolve(this.reportGenerator.getReport());
                    }
                }
            }));
        });
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.multiSubscriptionsReporter.start();
                yield this.multiSubscriptionsReporter.subscribe();
                yield Promise.all([this.multiSubscriptionsReporter.receiveMessage(), this.multiPublishersReporter.publish()]);
            }
            catch (err) {
                logger_1.Logger.error(`Requisition error: ${err}`);
                this.reportGenerator.addTest(event_1.DefaultHookEvents.ON_FINISH, { valid: false, tests: [{ name: 'Requisition error', description: err, valid: false }] });
            }
            if (!this.hasFinished) {
                yield this.onRequisitionFinish();
            }
            return this.reportGenerator.getReport();
        });
    }
    interrupt() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasFinished) {
                yield this.onRequisitionFinish();
                this.reportGenerator.addTest(event_1.DefaultHookEvents.ON_FINISH, {
                    valid: false,
                    tests: [{
                            valid: false,
                            name: 'Requisition interrupted',
                            description: 'Not finished yet. There was not enough time to finish the requisition'
                        }]
                });
            }
            return this.reportGenerator.getReport();
        });
    }
    onRequisitionFinish() {
        return __awaiter(this, void 0, void 0, function* () {
            this.hasFinished = true;
            yield this.multiSubscriptionsReporter.unsubscribe();
            yield this.executeOnFinishFunction();
            logger_1.Logger.info(`Start gathering reports`);
            this.reportGenerator.setPublishersReport(this.multiPublishersReporter.getReport());
            this.reportGenerator.setSubscriptionsReport(this.multiSubscriptionsReporter.getReport());
            this.reportGenerator.finish();
        });
    }
    executeOnInitFunction() {
        logger_1.Logger.debug(`Executing requisition onInit hook function`);
        const eventExecutor = new event_executor_1.EventExecutor(this.requisitionAttributes, event_1.DefaultHookEvents.ON_INIT, 'requisition');
        const elapsedTime = new Date().getTime() - this.startTime.getTime();
        eventExecutor.addArgument('elapsedTime', elapsedTime);
        const testModels = eventExecutor.execute();
        this.reportGenerator.addTest(event_1.DefaultHookEvents.ON_INIT, { valid: testModels.every(test => test.valid), tests: testModels, arguments: { elapsedTime: elapsedTime } });
        return testModels;
    }
    executeOnFinishFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.multiSubscriptionsReporter.onFinish();
            const onFinishEventExecutor = new event_executor_1.EventExecutor(this.requisitionAttributes, event_1.DefaultHookEvents.ON_FINISH, 'requisition');
            const elapsedTime = new Date().getTime() - this.startTime.getTime();
            onFinishEventExecutor.addArgument('elapsedTime', elapsedTime);
            const testModels = onFinishEventExecutor.execute();
            this.reportGenerator.addTest(event_1.DefaultHookEvents.ON_FINISH, { valid: testModels.every(test => test.valid), tests: testModels, arguments: { elapsedTime: elapsedTime } });
            this.multiPublishersReporter.onFinish();
        });
    }
}
RequisitionReporter.DEFAULT_TIMEOUT = 5 * 1000;
exports.RequisitionReporter = RequisitionReporter;
