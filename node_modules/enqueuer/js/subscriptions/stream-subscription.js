"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const subscription_1 = require("./subscription");
const net = __importStar(require("net"));
const tls = __importStar(require("tls"));
const logger_1 = require("../loggers/logger");
const store_1 = require("../configurations/store");
const handler_listener_1 = require("../handlers/handler-listener");
const fs = __importStar(require("fs"));
const timeout_1 = require("../timers/timeout");
const subscription_protocol_1 = require("../protocols/subscription-protocol");
class StreamSubscription extends subscription_1.Subscription {
    constructor(subscriptionAttributes) {
        super(subscriptionAttributes);
        this.type = this.type.toLowerCase();
        if (this.response && typeof subscriptionAttributes.response != 'string') {
            this.response = JSON.stringify(subscriptionAttributes.response, null, 2);
        }
    }
    receiveMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.loadStream) {
                return yield this.waitForData();
            }
            else if ('ssl' === (this.type || '').toLowerCase()) {
                yield this.sslServerGotConnection;
                return yield this.gotConnection(this.stream);
            }
            else {
                return new Promise((resolve, reject) => {
                    this.server.once('connection', (stream) => {
                        this.gotConnection(stream)
                            .then(() => resolve())
                            .catch((err) => reject(err));
                    });
                });
            }
        });
    }
    gotConnection(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stream = stream;
            logger_1.Logger.debug(`${this.type} readableStream got a connection ${this.stream}`);
            this.sendGreeting();
            yield this.waitForData();
        });
    }
    subscribe() {
        if (this.loadStream) {
            return this.reuseServer();
        }
        else {
            return this.createServer();
        }
    }
    unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            this.persistStream();
            if ('uds' === (this.type || '').toLowerCase() && fs.existsSync(this.path)) {
                fs.unlinkSync(this.path);
            }
            if (this.server) {
                this.server.close();
                this.server = null;
            }
            logger_1.Logger.debug(`${this.type} unsubscribed`);
        });
    }
    sendResponse() {
        if (!this.response) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            if (this.stream) {
                if (this.stream.write) {
                    logger_1.Logger.debug(`${this.type} readableStream (${this.stream.localPort}) sending response`);
                    this.stream.write(this.response, () => {
                        logger_1.Logger.debug(`${this.type} readableStream response sent`);
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            }
        });
    }
    reuseServer() {
        return new Promise((resolve, reject) => {
            try {
                this.tryToLoadStream();
                logger_1.Logger.debug(`${this.type} readableStream is reusing ${this.type} stream running on ${this.stream.localPort}`);
                resolve();
            }
            catch (err) {
                logger_1.Logger.error(err);
                this.createServer()
                    .then(() => resolve())
                    .catch((err) => reject(err));
            }
        });
    }
    createServer() {
        return new Promise((resolve, reject) => {
            this.createStream()
                .then(() => {
                logger_1.Logger.debug(`${this.type} readableStream is ready ${this.port || this.path}`);
                resolve();
            })
                .catch(err => {
                const message = `${this.type} readableStream errored ${this.port || this.path}: ${err}`;
                logger_1.Logger.error(message);
                reject(message);
            });
        });
    }
    createStream() {
        if ('tcp' === (this.type || '').toLowerCase()) {
            this.server = net.createServer();
            return new handler_listener_1.HandlerListener(this.server).listen(this.port);
        }
        else if ('ssl' === (this.type || '').toLowerCase()) {
            this.createSslConnection();
            return new handler_listener_1.HandlerListener(this.server).listen(this.port);
        }
        else {
            this.server = net.createServer();
            return new handler_listener_1.HandlerListener(this.server).listen(this.path);
        }
    }
    createSslConnection() {
        this['sslServerGotConnection'] = new Promise((resolve, reject) => {
            try {
                this.server = tls.createServer(this.options, (stream) => {
                    this.stream = stream;
                    resolve();
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    sendGreeting() {
        if (this.greeting && this.stream.write) {
            logger_1.Logger.debug(`${this.type} readableStream (${this.stream.localPort}) sending greeting message`);
            this.stream.write(this.greeting);
        }
    }
    tryToLoadStream() {
        logger_1.Logger.debug(`readableStream is loading ${this.type} stream: ${this.loadStream}`);
        this.stream = store_1.Store.getData()[this.loadStream];
        if (this.stream) {
            logger_1.Logger.debug(`readableStream loaded ${this.type} stream: ${this.loadStream} (${this.stream.localPort})`);
        }
        else {
            throw `Impossible to load ${this.type} stream: ${this.loadStream}`;
        }
    }
    waitForData() {
        return new Promise((resolve, reject) => {
            let message = {
                payload: undefined,
                stream: this.stream.address ? this.stream.address() : undefined,
                path: this.path
            };
            logger_1.Logger.trace(`${this.type} readableStream is waiting on data`);
            if (this.streamTimeout) {
                new timeout_1.Timeout(() => {
                    logger_1.Logger.trace(`Readable 'stream timeout' emitted`);
                    this.onEnd(message, resolve, reject);
                }).start(this.streamTimeout);
            }
            else {
                this.stream.once('end', () => {
                    logger_1.Logger.trace(`'End' timeout emitted`);
                    this.onEnd(message, resolve, reject);
                });
            }
            this.stream.on('data', (msg) => {
                this.onData(msg, message, resolve);
            });
        });
    }
    // ssl 8 - 8
    onEnd(message, resolve, reject) {
        if (message.payload !== undefined) {
            this['finished'] = true;
            if (!this.finished) {
                this.executeHookEvent('onMessageReceived', message);
            }
            resolve();
        }
        else {
            reject();
        }
    }
    onData(msg, message, resolve) {
        if (!this.finished) {
            logger_1.Logger.debug(`'${this.type}' readableStream got data '${msg}'`);
            if (message.payload === undefined) {
                message.payload = '';
            }
            message.payload += msg;
            if (!this.streamTimeout) {
                this['finished'] = true;
                this.executeHookEvent('onMessageReceived', message);
                resolve();
            }
        }
    }
    persistStream() {
        if (this.stream) {
            if (this.saveStream) {
                logger_1.Logger.debug(`Persisting subscription ${this.type} stream ${this.saveStream}`);
                store_1.Store.getData()[this.saveStream] = this.stream;
                this['saveStream'] = undefined;
            }
            else if (typeof (this.stream.end) === 'function') {
                logger_1.Logger.trace(`Ending ${this.type} stream`);
                this.stream.end();
            }
        }
    }
}
exports.StreamSubscription = StreamSubscription;
function entryPoint(mainInstance) {
    const createFunction = (subscriptionModel) => new StreamSubscription(subscriptionModel);
    const docs = {
        description: 'The stream subscription provides implementations of TCP/UDS servers',
        libraryHomepage: 'https://nodejs.org/api/net.html',
        schema: {
            attributes: {
                response: {
                    required: true,
                    type: 'text'
                },
                greeting: {
                    required: false,
                    type: 'text'
                },
                port: {
                    description: 'Defined when using TCP',
                    required: false,
                    type: 'int'
                },
                path: {
                    description: 'Defined when using UDS',
                    required: false,
                    type: 'string'
                },
                saveStream: {
                    description: 'Set it when you want to reuse this stream',
                    required: false,
                    type: 'string'
                },
                loadStream: {
                    description: 'Set it when you want to reuse an opened stream',
                    required: false,
                    type: 'string'
                },
                streamTimeout: {
                    description: 'Timeout to stop listening after the first byte is read',
                    required: false,
                    type: 'int'
                },
                options: {
                    description: 'Defined when using SSL. https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener',
                    required: false,
                    type: 'object'
                },
            },
            hooks: {
                onMessageReceived: {
                    arguments: {
                        payload: {},
                        stream: {},
                        path: {
                            description: 'Defined only when it is a UDS server',
                        }
                    }
                }
            }
        }
    };
    const tcp = new subscription_protocol_1.SubscriptionProtocol('tcp', createFunction, docs);
    const uds = new subscription_protocol_1.SubscriptionProtocol('uds', createFunction, docs);
    const ssl = new subscription_protocol_1.SubscriptionProtocol('ssl', createFunction, docs);
    mainInstance.protocolManager.addProtocol(tcp);
    mainInstance.protocolManager.addProtocol(uds);
    mainInstance.protocolManager.addProtocol(ssl);
}
exports.entryPoint = entryPoint;
