"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const subscription_1 = require("./subscription");
const logger_1 = require("../loggers/logger");
const http_container_pool_1 = require("../pools/http-container-pool");
const http_requester_1 = require("../pools/http-requester");
const subscription_protocol_1 = require("../protocols/subscription-protocol");
const http_authentication_factory_1 = require("../http-authentications/http-authentication-factory");
class HttpSubscription extends subscription_1.Subscription {
    constructor(subscriptionAttributes) {
        super(subscriptionAttributes);
        this.type = this.type.toLowerCase();
        this.secureServer = this.isSecureServer();
        this.proxy = this.isProxyServer();
        this['method'] = subscriptionAttributes.method || 'get';
        this['method'] = this.method.toLowerCase();
    }
    subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.expressApp = yield http_container_pool_1.HttpContainerPool.getApp(this.port, this.secureServer, this.credentials);
            }
            catch (err) {
                const message = `Error in ${this.type} subscription: ${err}`;
                logger_1.Logger.error(message);
                throw err;
            }
        });
    }
    unsubscribe() {
        return http_container_pool_1.HttpContainerPool.releaseApp(this.port);
    }
    sendResponse() {
        logger_1.Logger.trace(`${this.type} sending response: ${JSON.stringify(this.response)}`);
        try {
            Object.keys(this.response.headers || {}).forEach(key => {
                this.responseToClientHandler.header(key, this.response.headers[key]);
            });
            this.responseToClientHandler.status(this.response.status).send('' + this.response.payload);
            logger_1.Logger.debug(`${this.type} response sent`);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`${this.type} response back sending error: ${err}`);
        }
    }
    onMessageReceivedTests(messageReceived) {
        if (this.authentication && messageReceived) {
            logger_1.Logger.debug(`${this.type} authenticating message with ${JSON.stringify(Object.keys(this.authentication), null, 2)}`);
            const verifier = new http_authentication_factory_1.HttpAuthenticationFactory().create(this.authentication);
            return verifier.verify(messageReceived.headers.authorization);
        }
        return [];
    }
    receiveMessage() {
        if (this.proxy) {
            return this.proxyServerMessageReceiving();
        }
        else {
            return this.realServerMessageReceiving();
        }
    }
    realServerMessageReceiving() {
        return new Promise((resolve) => {
            logger_1.Logger.debug(`Listening to (${this.method.toUpperCase()}) ${this.port}:${this.endpoint}`);
            const realServerFunction = (request, responseHandler, next) => {
                logger_1.Logger.debug(`${this.type.toUpperCase()}:${this.port} got hit (${this.method.toUpperCase()}) ${this.endpoint}: ${request.rawBody}`);
                if (this.responseToClientHandler) {
                    next();
                }
                this.responseToClientHandler = responseHandler;
                this.onMessageReceivedTests(request);
                this.executeHookEvent('onMessageReceived', this.createMessageReceivedStructure(request));
                resolve();
            };
            this.expressApp[this.method](this.endpoint, (request, responseHandler, next) => realServerFunction(request, responseHandler, next));
        });
    }
    proxyServerMessageReceiving() {
        return new Promise((resolve, reject) => {
            logger_1.Logger.debug(`Listening to (${this.method})${this.port}${this.endpoint}/*`);
            const proxyNamedFunction = (originalRequest, responseHandler, next) => {
                this.responseToClientHandler = responseHandler;
                logger_1.Logger.debug(`${this.type}:${this.port} got hit (${this.method}) ${this.endpoint}: ${originalRequest.rawBody}`);
                this.redirect['url'] = this.redirect.url + originalRequest.url.replace(this.endpoint, '');
                this.redirect['headers'] = originalRequest.headers;
                this.redirect['payload'] = originalRequest.rawBody;
                this.onMessageReceivedTests(originalRequest);
                this.executeHookEvent('onOriginalMessageReceived', this.createMessageReceivedStructure(originalRequest));
                this.redirectCall()
                    .then((redirectionResponse) => {
                    logger_1.Logger.trace(`${this.type}:${this.port} got redirection response: ` +
                        `${JSON.stringify(redirectionResponse, null, 2)}`);
                    this.response = {
                        status: redirectionResponse.statusCode,
                        payload: redirectionResponse.body,
                        headers: redirectionResponse.headers
                    };
                    this.executeHookEvent('onMessageReceived', redirectionResponse);
                    resolve();
                    next();
                })
                    .catch(err => {
                    reject(err);
                    next();
                });
            };
            this.expressApp[this.method](this.endpoint + '/*', proxyNamedFunction);
        });
    }
    createMessageReceivedStructure(message) {
        return {
            headers: message.headers,
            params: message.params,
            query: message.query,
            url: message.url,
            body: message.rawBody
        };
    }
    redirectCall() {
        logger_1.Logger.info(`Redirecting call from ${this.endpoint} (${this.port}) to ${this.url}`);
        return new http_requester_1.HttpRequester(this.redirect.url, this.redirect.method || 'get', this.redirect.headers, this.redirect.payload, this.redirect.timeout || 3000)
            .request();
    }
    isSecureServer() {
        if (this.type) {
            if (this.type.indexOf('https') != -1) {
                return true;
            }
            else if (this.type.indexOf('http') != -1) {
                return false;
            }
        }
        throw `Http server type is not known: ${this.type}`;
    }
    isProxyServer() {
        if (this.type) {
            return this.type.indexOf('proxy') != -1;
        }
        throw `Http server type is not known: ${this.type}`;
    }
}
function entryPoint(mainInstance) {
    const protocol = new subscription_protocol_1.SubscriptionProtocol('http', (subscriptionModel) => new HttpSubscription(subscriptionModel), {
        description: 'The HTTP subscription provides implementations of http servers and proxies',
        libraryHomepage: 'https://expressjs.com/',
        schema: {
            attributes: {
                endpoint: {
                    required: true,
                    type: 'string',
                    example: '/almighty/enqueuer'
                },
                method: {
                    required: false,
                    type: 'string',
                    defaultValue: 'GET',
                    listValues: ['GET', 'POST', 'PATCH', 'PUT', 'OPTIONS', 'HEAD', 'DELETE']
                },
                port: {
                    required: true,
                    type: 'int'
                },
                timeout: {
                    required: false,
                    type: 'int',
                    defaultValue: 3000,
                    suffix: 'ms'
                },
                credentials: {
                    required: false,
                    description: 'Values used when being used as a secure server',
                    type: {
                        key: {
                            required: true,
                            type: 'string'
                        },
                        cert: {
                            required: true,
                            type: 'string'
                        }
                    }
                },
                redirect: {
                    description: 'Values used when being used as a proxy subscription',
                    type: {
                        url: {
                            required: true,
                            type: 'string',
                            example: 'https://github.com/enqueuer-land/enqueuer'
                        },
                        method: {
                            required: false,
                            type: 'string',
                            defaultValue: 'GET',
                            listValues: ['GET', 'POST', 'PATCH', 'PUT', 'OPTIONS', 'HEAD', 'DELETE']
                        },
                        timeout: {
                            required: false,
                            type: 'int',
                            defaultValue: 3000,
                            suffix: 'ms'
                        },
                        headers: {
                            description: '',
                            type: 'object',
                            defaultValue: {}
                        },
                    }
                },
                headers: {
                    description: '',
                    type: 'object',
                    defaultValue: {}
                },
                response: {
                    description: 'Response to be given when not being used as proxy',
                    type: {
                        status: {
                            required: true,
                            type: 'int'
                        },
                        payload: {
                            required: true,
                            type: 'any'
                        }
                    },
                    defaultValue: {}
                },
            },
            hooks: {
                onMessageReceived: {
                    description: '',
                    arguments: {
                        params: {},
                        query: {},
                        body: {},
                        url: {},
                    }
                },
                onOriginalMessageReceived: {
                    description: 'Useful when using a proxy subscription. ' +
                        'Gets called when the proxy is hit, before actually proxying the message',
                    arguments: {
                        params: {},
                        query: {},
                        body: {},
                        url: {},
                    }
                }
            }
        }
    })
        .addAlternativeName('https', 'http-proxy', 'https-proxy', 'http-server', 'https-server')
        .setLibrary('express');
    mainInstance.protocolManager.addProtocol(protocol);
}
exports.entryPoint = entryPoint;
