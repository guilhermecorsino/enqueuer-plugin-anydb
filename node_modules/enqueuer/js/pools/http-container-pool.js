"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../loggers/logger");
const http_container_1 = require("./http-container");
class HttpContainerPool {
    constructor() {
        this.containers = {};
    }
    static getApp(port, secure = false, credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = HttpContainerPool.getInstance();
            logger_1.Logger.trace(`Getting a Http server ${port}`);
            let httpContainer = self.containers[port];
            if (!httpContainer) {
                logger_1.Logger.trace(`Creating a new Http server ${port}`);
                httpContainer = new http_container_1.HttpContainer(port, credentials);
                self.containers[port] = httpContainer;
                return yield httpContainer.acquire();
            }
            else {
                logger_1.Logger.trace(`Reusing Http server ${port}`);
                return yield httpContainer.acquire();
            }
        });
    }
    static releaseApp(port) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = HttpContainerPool.getInstance();
            logger_1.Logger.trace(`Current containers: {${Object.keys(self.containers)}}`);
            const httpContainer = self.containers[port];
            if (httpContainer) {
                const number = yield httpContainer.release();
                if (number === 0) {
                    delete self.containers[port];
                }
            }
            else {
                logger_1.Logger.trace(`No bound http-container to be released (${port})`);
            }
        });
    }
    static getInstance() {
        if (!HttpContainerPool.instance) {
            HttpContainerPool.instance = new HttpContainerPool();
        }
        return HttpContainerPool.instance;
    }
}
exports.HttpContainerPool = HttpContainerPool;
