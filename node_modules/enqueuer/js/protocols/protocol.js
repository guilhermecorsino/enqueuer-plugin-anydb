"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../loggers/logger");
const event_1 = require("../models/events/event");
const subscription_reporter_1 = require("../reporters/subscription/subscription-reporter");
var ProtocolType;
(function (ProtocolType) {
    ProtocolType[ProtocolType["PUBLISHER"] = 0] = "PUBLISHER";
    ProtocolType[ProtocolType["SUBSCRIPTION"] = 1] = "SUBSCRIPTION";
})(ProtocolType = exports.ProtocolType || (exports.ProtocolType = {}));
class Protocol {
    constructor(name, type, protocolDocumentation) {
        this.name = name;
        this.type = type;
        this.documentation = this.createDefaultDocumentation();
        if (protocolDocumentation) {
            this.documentation = protocolDocumentation;
        }
        this.addDefaultValues(type);
    }
    addDefaultValues(type) {
        if (!this.documentation.schema) {
            this.documentation.schema = {};
        }
        if (!this.documentation.schema.hooks) {
            this.documentation.schema.hooks = {};
        }
        this.documentation.schema.hooks = Object.assign({}, this.documentation.schema.hooks, {
            [event_1.DefaultHookEvents.ON_INIT]: {
                arguments: {},
                description: 'Executed as soon as the component is initialized',
            },
            [event_1.DefaultHookEvents.ON_FINISH]: {
                arguments: {},
                description: 'Executed when the component is about to finish',
            }
        });
        Object.keys(this.documentation.schema.hooks).forEach((key) => {
            const hookArguments = this.documentation.schema.hooks[key].arguments;
            this.documentation.schema.hooks[key].arguments = Object.assign({}, hookArguments, { elapsedTime: {
                    description: 'Number of milliseconds since the instantiation of the component'
                }, this: {
                    description: 'Pointer to the component'
                } });
        });
        if (!this.documentation.schema.attributes) {
            this.documentation.schema.attributes = {};
        }
        this.documentation.schema.attributes.ignore = {
            type: 'boolean',
            required: false,
            defaultValue: false,
            description: 'Defines if the component should be ignored'
        };
        this.documentation.schema.attributes.name = {
            type: 'string',
            required: false,
            description: 'Defines the component name'
        };
        this.documentation.schema.attributes.type = {
            type: 'string',
            required: true,
            description: 'Protocol identifier'
        };
        if (type == ProtocolType.SUBSCRIPTION) {
            this.documentation.schema.attributes.timeout = {
                type: 'int',
                suffix: 'ms',
                required: false,
                defaultValue: subscription_reporter_1.SubscriptionReporter.DEFAULT_TIMEOUT,
                description: 'Defines the subscription time out'
            };
            this.documentation.schema.attributes.avoid = {
                type: 'boolean',
                required: false,
                defaultValue: false,
                description: 'Defines if the subscription should be avoided'
            };
        }
    }
    createDefaultDocumentation() {
        return {
            schema: {
                attributes: {},
                hooks: {
                    [event_1.DefaultHookEvents.ON_INIT]: {
                        arguments: {}
                    },
                    [event_1.DefaultHookEvents.ON_FINISH]: {
                        arguments: {}
                    }
                }
            }
        };
    }
    isSubscription() {
        return this.type === ProtocolType.SUBSCRIPTION;
    }
    isPublisher() {
        return this.type === ProtocolType.PUBLISHER;
    }
    getName() {
        return this.name;
    }
    getDescription() {
        if (Object.keys(this.documentation).length > 0) {
            return Object.assign({}, this.documentation, { name: this.name });
        }
        return { name: this.name };
    }
    addAlternativeName(...alternativeNames) {
        let uniqueAlternativeNames;
        if (this.alternativeNames) {
            uniqueAlternativeNames = new Set(this.alternativeNames.concat(alternativeNames));
        }
        else {
            uniqueAlternativeNames = new Set(alternativeNames);
        }
        this.alternativeNames = Array.from(uniqueAlternativeNames);
        return this;
    }
    setLibrary(libraryName) {
        this.library = this.createLibrary(libraryName);
        return this;
    }
    matches(type) {
        if (typeof type === 'string') {
            try {
                return [this.name].concat(this.alternativeNames || [])
                    .some((name) => name.toUpperCase().includes(type.toUpperCase()));
            }
            catch (exc) {
                logger_1.Logger.warning(`Error comparing protocols with given type '${type}': ${exc}`);
            }
        }
        return false;
    }
    isLibraryInstalled(libraryName) {
        try {
            require.resolve(libraryName);
            return true;
        }
        catch (e) {
            /* do nothing */
        }
        return false;
    }
    createLibrary(name) {
        return {
            name: name,
            installed: this.isLibraryInstalled(name)
        };
    }
}
exports.Protocol = Protocol;
