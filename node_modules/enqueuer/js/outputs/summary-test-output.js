"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const tests_analyzer_1 = require("./tests-analyzer");
const test_model_1 = require("../models/outputs/test-model");
class SummaryTestOutput {
    constructor(report, options) {
        this.options = {
            level: 0,
            maxLevel: 100,
            tabulationPerLevel: 6,
            summarySpacing: 90,
            showPassingTests: false
        };
        this.report = report;
        if (options && options.level !== undefined) {
            this.options.level = options.level;
        }
        else if (report.level) {
            this.options.level = report.level;
        }
        this.options = Object.assign({}, this.options, options);
    }
    print() {
        if (this.options.maxLevel === undefined || this.options.level <= this.options.maxLevel) {
            this.printChildren();
            this.printSelf();
        }
    }
    printChildren() {
        const reportLeaves = (this.report.subscriptions || [])
            .concat(this.report.publishers || []);
        for (const leaf of reportLeaves) {
            const options = Object.assign({}, this.options, {
                level: this.options.level + 1,
            });
            new SummaryTestOutput(leaf, options).print();
        }
    }
    printSelf() {
        const testAnalyzer = new tests_analyzer_1.TestsAnalyzer().addTest(this.report);
        console.log(this.formatTitle(testAnalyzer) + this.createSummary(testAnalyzer));
        this.printFailingTests(this.report, []);
    }
    formatTitle(testAnalyzer) {
        const initialTabulation = this.createEmptyStringSized(2 * this.options.tabulationPerLevel);
        const tagTitleSeparation = this.createEmptyStringSized(this.options.level * this.options.tabulationPerLevel);
        const titleSizeSeparation = initialTabulation.length + 6 + tagTitleSeparation.length + this.report.name.length;
        let formattedString = initialTabulation;
        let nameColorFunction;
        if (testAnalyzer.getTests().length === 0) {
            formattedString += `${chalk_1.default.black.bgHex('#999999')('[NULL]')} `;
            nameColorFunction = chalk_1.default.hex('#999999');
        }
        else if (this.report.ignored || testAnalyzer.getIgnoredList().length === testAnalyzer.getTests().length) {
            formattedString += `${chalk_1.default.black.bgYellow('[SKIP]')} `;
            nameColorFunction = chalk_1.default.yellow;
        }
        else if (testAnalyzer.getFailingTests().length > 0) {
            formattedString += `${chalk_1.default.black.bgRed('[FAIL]')} `;
            nameColorFunction = chalk_1.default.red;
        }
        else { //if (this.report.valid)
            formattedString += `${chalk_1.default.black.bgGreen('[PASS]')} `;
            nameColorFunction = chalk_1.default.green;
        }
        formattedString += tagTitleSeparation;
        const iterationCounter = (this.report.totalIterations > 1) ? ` [${this.report.iteration}]` : '';
        formattedString += nameColorFunction(this.report.name + iterationCounter);
        formattedString += this.createEmptyStringSized(this.options.summarySpacing - titleSizeSeparation);
        return formattedString;
    }
    createEmptyStringSized(length) {
        let blank = '';
        while (--length > 0) {
            blank = blank.concat(' ');
        }
        return blank;
    }
    createSummary(testAnalyzer) {
        const percentage = testAnalyzer.getPercentage();
        const testsNumber = testAnalyzer.getNotIgnoredTests().length;
        let message = `${testAnalyzer.getPassingTests().length} tests passing of ${testsNumber} (${percentage}%)`;
        const ignoredTests = testAnalyzer.getIgnoredList();
        if (ignoredTests.length > 0) {
            message += chalk_1.default.yellow(` - ${ignoredTests.length} ignored -`);
        }
        if (this.report.time) {
            const totalTime = this.report.time.totalTime;
            message += ` ran in ${totalTime}ms`;
        }
        return this.getColor(percentage)(message);
    }
    printFailingTests(report, hierarchy) {
        const failing = !test_model_1.testModelIsPassing(report);
        if (failing || this.options.showPassingTests) {
            Object.keys(report.hooks || {})
                .forEach((key) => this.printHookTests(report.hooks[key], key, hierarchy));
            (report.subscriptions || [])
                .concat(report.publishers || [])
                .concat(report.requisitions || [])
                .forEach(((leaf) => {
                const iterationCounter = (leaf.totalIterations > 1) ? ` [${leaf.iteration}]` : '';
                this.printFailingTests(leaf, hierarchy.concat(leaf.name + iterationCounter));
            }));
        }
    }
    printHookTests(hook, hookName, hierarchy) {
        hook.tests
            .filter((test) => !test_model_1.testModelIsPassing(test) || this.options.showPassingTests)
            .forEach((test, index) => {
            const initialTabulation = this.createEmptyStringSized((this.options.level + 4) * this.options.tabulationPerLevel);
            let color;
            if (test.ignored) {
                color = chalk_1.default.yellow;
            }
            else if (test.valid) {
                color = chalk_1.default.green;
            }
            else {
                color = chalk_1.default.red;
            }
            if (index === 0) {
                const hierarchyMessage = initialTabulation + hierarchy
                    .map(level => color(level) + chalk_1.default.gray(' â€º '))
                    .concat(hookName)
                    .join('');
                console.log(hierarchyMessage);
            }
            console.log(color(`${initialTabulation}${this.createEmptyStringSized(this.options.tabulationPerLevel)}${test.name}`));
            console.log(chalk_1.default.reset(`${initialTabulation}${this
                .createEmptyStringSized(2 * this.options.tabulationPerLevel)}${test.description}\n`));
        });
    }
    getColor(percentage) {
        if (percentage == 100) {
            return chalk_1.default.green;
        }
        else if (percentage > 50) {
            return chalk_1.default.yellow;
        }
        return chalk_1.default.red;
    }
}
exports.SummaryTestOutput = SummaryTestOutput;
